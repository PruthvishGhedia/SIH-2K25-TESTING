[
  {
    "projectId": "cfa9b81f-b57b-4c59-a209-6a1a1983491f",
    "testId": "8a240e1c-a56a-4893-9111-0339789aa17c",
    "userId": "e4384488-b011-7080-1f43-4f7481be94d5",
    "title": "TC001-student registration with document upload and admission status tracking",
    "description": "Test the student registration API to ensure it accepts required documents, processes the registration successfully, and allows tracking of admission status.",
    "code": "import requests\nimport time\n\nBASE_URL = \"http://localhost:5000\"\nTIMEOUT = 30\n\ndef test_student_registration_with_document_upload_and_admission_status_tracking():\n    # Define headers and sample student registration data with documents\n    headers = {\n        \"Accept\": \"application/json\"\n    }\n    # Sample student registration payload including a required document\n    registration_payload = {\n        \"firstName\": \"Test\",\n        \"lastName\": \"Student\",\n        \"dateOfBirth\": \"2005-05-20\",\n        \"email\": \"test.student@example.com\",\n        \"phone\": \"+1234567890\",\n        \"address\": \"123 Test Lane\",\n        \"documents\": [\n            {\n                \"documentType\": \"birth_certificate\",\n                \"fileName\": \"birth_certificate.pdf\",\n                \"fileContent\": \"VGhpcyBpcyBhIHRlc3QgYmlydGggY2VydGlmaWNhdGUgY29udGVudC4=\"  # Base64 encoded dummy content\n            }\n        ]\n    }\n\n    # Step 1: Register student with document upload\n    try:\n        response = requests.post(\n            f\"{BASE_URL}/api/students\",\n            json=registration_payload,\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        assert response.status_code == 201, f\"Expected 201 Created, got {response.status_code}\"\n        reg_data = response.json()\n        assert \"studentId\" in reg_data, \"Response missing studentId\"\n        student_id = reg_data[\"studentId\"]\n\n        # Step 2: Confirm registration success status (if included in response)\n        # - if there is a status field, check for success\n        if \"registrationStatus\" in reg_data:\n            assert reg_data[\"registrationStatus\"].lower() in (\"submitted\", \"processing\", \"registered\"), \\\n                f\"Unexpected registrationStatus value: {reg_data['registrationStatus']}\"\n\n        # Step 3: Track admission status - poll the status endpoint until final status or timeout (max ~30s)\n        admission_status = None\n        for _ in range(6):\n            status_response = requests.get(\n                f\"{BASE_URL}/api/students/{student_id}/admission-status\",\n                headers=headers,\n                timeout=TIMEOUT\n            )\n            assert status_response.status_code == 200, f\"Admission status fetch failed: {status_response.status_code}\"\n            status_data = status_response.json()\n            assert \"admissionStatus\" in status_data, \"Response missing admissionStatus\"\n            admission_status = status_data[\"admissionStatus\"].lower()\n            if admission_status in (\"admitted\", \"rejected\", \"cancelled\"):\n                break\n            time.sleep(5)  # wait 5 seconds before polling again\n\n        assert admission_status in (\"admitted\", \"rejected\", \"cancelled\", \"processing\", \"pending\"), \\\n            f\"Unexpected admission status: {admission_status}\"\n\n    finally:\n        # Cleanup: Delete the student registration to avoid stale data\n        if 'student_id' in locals():\n            try:\n                del_response = requests.delete(\n                    f\"{BASE_URL}/api/students/{student_id}\",\n                    headers=headers,\n                    timeout=TIMEOUT\n                )\n                # Allow 200 or 204 as successful deletion responses\n                assert del_response.status_code in (200, 204), f\"Failed to delete test student, status: {del_response.status_code}\"\n            except Exception:\n                # Suppress exceptions during cleanup\n                pass\n\ntest_student_registration_with_document_upload_and_admission_status_tracking()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 82, in <module>\n  File \"<string>\", line 37, in test_student_registration_with_document_upload_and_admission_status_tracking\nAssertionError: Expected 201 Created, got 404\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-29T19:30:05.162Z",
    "modified": "2025-09-29T19:31:15.724Z"
  },
  {
    "projectId": "cfa9b81f-b57b-4c59-a209-6a1a1983491f",
    "testId": "8d0e05a9-43f8-453e-98b1-ae06df4f7378",
    "userId": "e4384488-b011-7080-1f43-4f7481be94d5",
    "title": "TC002-attendance marking and attendance report generation",
    "description": "Verify the attendance marking API for faculty and admin, ensuring attendance is recorded accurately and attendance reports are generated correctly.",
    "code": "import requests\nimport datetime\n\nBASE_URL = \"http://localhost:5000\"\nTIMEOUT = 30\n\ndef test_attendance_marking_and_report_generation():\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n\n    # Create a sample attendance record for testing\n    attendance_payload = {\n        \"facultyId\": 1,\n        \"date\": datetime.date.today().isoformat(),\n        \"classId\": 1,\n        \"subjectId\": 1,\n        \"attendanceRecords\": [\n            {\"studentId\": 101, \"status\": \"present\"},\n            {\"studentId\": 102, \"status\": \"absent\"},\n            {\"studentId\": 103, \"status\": \"present\"}\n        ]\n    }\n\n    attendance_id = None\n\n    try:\n        # Mark attendance - POST /attendance\n        mark_attendance_resp = requests.post(\n            f\"{BASE_URL}/attendance\",\n            json=attendance_payload,\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        assert mark_attendance_resp.status_code == 201 or mark_attendance_resp.status_code == 200, \\\n            f\"Failed to mark attendance. Status code: {mark_attendance_resp.status_code}\"\n        attendance_data = mark_attendance_resp.json()\n        attendance_id = attendance_data.get(\"attendanceId\") or attendance_data.get(\"id\")\n        assert attendance_id is not None, \"Response missing attendance ID\"\n\n        # Retrieve the marked attendance record - GET /attendance/{attendanceId}\n        get_attendance_resp = requests.get(\n            f\"{BASE_URL}/attendance/{attendance_id}\",\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        assert get_attendance_resp.status_code == 200, \\\n            f\"Failed to fetch attendance record. Status code: {get_attendance_resp.status_code}\"\n        attendance_record = get_attendance_resp.json()\n        assert attendance_record[\"facultyId\"] == attendance_payload[\"facultyId\"]\n        assert attendance_record[\"date\"] == attendance_payload[\"date\"]\n        assert attendance_record[\"classId\"] == attendance_payload[\"classId\"]\n        assert attendance_record[\"subjectId\"] == attendance_payload[\"subjectId\"]\n        assert isinstance(attendance_record.get(\"attendanceRecords\"), list)\n        assert len(attendance_record[\"attendanceRecords\"]) == len(attendance_payload[\"attendanceRecords\"])\n\n        # Generate attendance report - GET /attendance/report?classId=1&subjectId=1&date=YYYY-MM-DD\n        report_params = {\n            \"classId\": attendance_payload[\"classId\"],\n            \"subjectId\": attendance_payload[\"subjectId\"],\n            \"date\": attendance_payload[\"date\"]\n        }\n        report_resp = requests.get(\n            f\"{BASE_URL}/attendance/report\",\n            headers=headers,\n            params=report_params,\n            timeout=TIMEOUT\n        )\n        assert report_resp.status_code == 200, \\\n            f\"Failed to generate attendance report. Status code: {report_resp.status_code}\"\n        report_data = report_resp.json()\n        assert \"classId\" in report_data and report_data[\"classId\"] == attendance_payload[\"classId\"]\n        assert \"subjectId\" in report_data and report_data[\"subjectId\"] == attendance_payload[\"subjectId\"]\n        assert \"date\" in report_data and report_data[\"date\"] == attendance_payload[\"date\"]\n        assert \"attendanceSummary\" in report_data and isinstance(report_data[\"attendanceSummary\"], dict)\n\n    finally:\n        # Cleanup - delete the attendance record if created - DELETE /attendance/{attendanceId}\n        if attendance_id:\n            try:\n                del_resp = requests.delete(\n                    f\"{BASE_URL}/attendance/{attendance_id}\",\n                    headers=headers,\n                    timeout=TIMEOUT\n                )\n                assert del_resp.status_code == 200 or del_resp.status_code == 204, \\\n                    f\"Failed to delete attendance record. Status code: {del_resp.status_code}\"\n            except Exception:\n                pass\n\ntest_attendance_marking_and_report_generation()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 91, in <module>\n  File \"<string>\", line 35, in test_attendance_marking_and_report_generation\nAssertionError: Failed to mark attendance. Status code: 404\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-29T19:30:05.176Z",
    "modified": "2025-09-29T19:30:51.093Z"
  },
  {
    "projectId": "cfa9b81f-b57b-4c59-a209-6a1a1983491f",
    "testId": "cebba33b-d8e1-491b-87bb-f1c292c8a378",
    "userId": "e4384488-b011-7080-1f43-4f7481be94d5",
    "title": "TC003-library book issue and return processing",
    "description": "Test the library management APIs to confirm that book issuance and returns are processed correctly and the library catalog is updated accordingly.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:5000\"\nTIMEOUT = 30\nHEADERS = {\"Content-Type\": \"application/json\"}\n\ndef test_library_book_issue_and_return_processing():\n    \"\"\"Test library book issue and return processing, and catalog update.\"\"\"\n\n    # Step 1: Create a new book resource to issue and return\n    new_book_payload = {\n        \"title\": f\"Test Book {uuid.uuid4()}\",\n        \"author\": \"Test Author\",\n        \"isbn\": f\"ISBN-{uuid.uuid4()}\",\n        \"copies\": 3\n    }\n\n    book_id = None\n    issued_record_id = None\n\n    try:\n        # Create a new book in the catalog\n        resp_create_book = requests.post(\n            f\"{BASE_URL}/library/books\",\n            json=new_book_payload,\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert resp_create_book.status_code == 201, f\"Failed to create book, status: {resp_create_book.status_code}\"\n        book_data = resp_create_book.json()\n        book_id = book_data.get(\"id\")\n        assert book_id is not None, \"Created book ID missing\"\n\n        # Step 2: Issue the book to a user (simulate userId)\n        issue_payload = {\n            \"bookId\": book_id,\n            \"userId\": str(uuid.uuid4()),  # Simulated user ID\n            \"issueDate\": \"2025-09-29\"\n        }\n\n        resp_issue = requests.post(\n            f\"{BASE_URL}/library/issue\",\n            json=issue_payload,\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert resp_issue.status_code == 201, f\"Book issuance failed, status: {resp_issue.status_code}\"\n        issue_data = resp_issue.json()\n        issued_record_id = issue_data.get(\"issueId\")\n        assert issued_record_id is not None, \"Issue record ID missing\"\n\n        # Step 3: Verify the catalog updates - available copies should reduce by 1\n        resp_catalog = requests.get(\n            f\"{BASE_URL}/library/books/{book_id}\",\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert resp_catalog.status_code == 200, f\"Failed to fetch updated book catalog, status: {resp_catalog.status_code}\"\n        catalog_data = resp_catalog.json()\n        expected_copies = new_book_payload[\"copies\"] - 1\n        actual_copies = catalog_data.get(\"availableCopies\", catalog_data.get(\"copies\"))\n        assert actual_copies == expected_copies, f\"Available copies incorrect after issue. Expected: {expected_copies}, Got: {actual_copies}\"\n\n        # Step 4: Return the book\n        return_payload = {\n            \"issueId\": issued_record_id,\n            \"returnDate\": \"2025-10-01\"\n        }\n        resp_return = requests.post(\n            f\"{BASE_URL}/library/return\",\n            json=return_payload,\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert resp_return.status_code == 200, f\"Book return failed, status: {resp_return.status_code}\"\n        return_data = resp_return.json()\n        assert return_data.get(\"status\") == \"returned\", f\"Return status unexpected: {return_data.get('status')}\"\n\n        # Step 5: Verify the catalog updates - available copies restored\n        resp_catalog_after_return = requests.get(\n            f\"{BASE_URL}/library/books/{book_id}\",\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert resp_catalog_after_return.status_code == 200, f\"Failed to fetch updated catalog after return, status: {resp_catalog_after_return.status_code}\"\n        catalog_after_return_data = resp_catalog_after_return.json()\n        final_copies = catalog_after_return_data.get(\"availableCopies\", catalog_after_return_data.get(\"copies\"))\n        assert final_copies == new_book_payload[\"copies\"], f\"Available copies not restored after return. Expected: {new_book_payload['copies']}, Got: {final_copies}\"\n\n    finally:\n        # Cleanup: delete the created book resource if exists\n        if issued_record_id:\n            try:\n                requests.delete(\n                    f\"{BASE_URL}/library/issue/{issued_record_id}\",\n                    headers=HEADERS,\n                    timeout=TIMEOUT\n                )\n            except Exception:\n                pass\n\n        if book_id:\n            try:\n                requests.delete(\n                    f\"{BASE_URL}/library/books/{book_id}\",\n                    headers=HEADERS,\n                    timeout=TIMEOUT\n                )\n            except Exception:\n                pass\n\ntest_library_book_issue_and_return_processing()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 113, in <module>\n  File \"<string>\", line 30, in test_library_book_issue_and_return_processing\nAssertionError: Failed to create book, status: 404\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-29T19:30:05.190Z",
    "modified": "2025-09-29T19:30:49.799Z"
  },
  {
    "projectId": "cfa9b81f-b57b-4c59-a209-6a1a1983491f",
    "testId": "53d07d5c-ff21-433e-b23c-4a9f492a2110",
    "userId": "e4384488-b011-7080-1f43-4f7481be94d5",
    "title": "TC004-hostel room allocation and fee management",
    "description": "Validate the hostel allocation API to ensure rooms are assigned correctly to students and associated hostel fees are managed accurately.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:5000\"\nTIMEOUT = 30\n\ndef test_hostel_room_allocation_and_fee_management():\n    headers = {\"Content-Type\": \"application/json\"}\n\n    student_payload = {\n        \"name\": \"Test Student\",\n        \"email\": \"teststudent@example.com\",\n        \"department\": \"Computer Science\",\n        \"year\": 2,\n        \"documents\": [\"id_card.pdf\", \"transcript.pdf\"]\n    }\n    room_payload = {\n        \"room_number\": \"101A\",\n        \"capacity\": 1,\n        \"block\": \"A\"\n    }\n    fee_payload = {\n        \"amount\": 1500,\n        \"due_date\": \"2025-12-31\"\n    }\n\n    student_id = None\n    room_id = None\n    allocation_id = None\n    try:\n        # Create student\n        student_resp = requests.post(f\"{BASE_URL}/api/student\", json=student_payload, headers=headers, timeout=TIMEOUT)\n        assert student_resp.status_code == 201, f\"Expected 201 Created, got {student_resp.status_code}\"\n        student_id = student_resp.json().get(\"id\")\n        assert student_id, \"Student ID not returned\"\n\n        # Create room\n        room_resp = requests.post(f\"{BASE_URL}/api/hostel/rooms\", json=room_payload, headers=headers, timeout=TIMEOUT)\n        assert room_resp.status_code == 201, f\"Expected 201 Created for room, got {room_resp.status_code}\"\n        room_id = room_resp.json().get(\"id\")\n        assert room_id, \"Room ID not returned\"\n\n        # Allocate room to student\n        allocation_payload = {\n            \"student_id\": student_id,\n            \"room_id\": room_id,\n            \"allocation_date\": \"2025-10-01\"\n        }\n        alloc_resp = requests.post(f\"{BASE_URL}/api/hostel/allocations\", json=allocation_payload, headers=headers, timeout=TIMEOUT)\n        assert alloc_resp.status_code == 201, f\"Expected 201 Created for allocation, got {alloc_resp.status_code}\"\n        allocation_id = alloc_resp.json().get(\"id\")\n        assert allocation_id, \"Allocation ID not returned\"\n\n        # Assign fee to allocation\n        fee_payload_update = {\n            \"allocation_id\": allocation_id,\n            \"amount\": fee_payload[\"amount\"],\n            \"due_date\": fee_payload[\"due_date\"],\n            \"paid\": False\n        }\n        fee_resp = requests.post(f\"{BASE_URL}/api/hostel/fees\", json=fee_payload_update, headers=headers, timeout=TIMEOUT)\n        assert fee_resp.status_code == 201, f\"Expected 201 Created for fee, got {fee_resp.status_code}\"\n        fee_id = fee_resp.json().get(\"id\")\n        assert fee_id, \"Fee ID not returned\"\n\n        # Retrieve allocation to verify\n        get_alloc_resp = requests.get(f\"{BASE_URL}/api/hostel/allocations/{allocation_id}\", headers=headers, timeout=TIMEOUT)\n        assert get_alloc_resp.status_code == 200, f\"Expected 200 OK for allocation retrieval, got {get_alloc_resp.status_code}\"\n        alloc_data = get_alloc_resp.json()\n        assert alloc_data.get(\"student_id\") == student_id, \"Allocated student_id mismatch\"\n        assert alloc_data.get(\"room_id\") == room_id, \"Allocated room_id mismatch\"\n\n        # Retrieve fee to verify\n        get_fee_resp = requests.get(f\"{BASE_URL}/api/hostel/fees/{fee_id}\", headers=headers, timeout=TIMEOUT)\n        assert get_fee_resp.status_code == 200, f\"Expected 200 OK for fee retrieval, got {get_fee_resp.status_code}\"\n        fee_data = get_fee_resp.json()\n        assert fee_data.get(\"allocation_id\") == allocation_id, \"Fee allocation_id mismatch\"\n        assert fee_data.get(\"amount\") == fee_payload[\"amount\"], \"Fee amount mismatch\"\n        assert fee_data.get(\"paid\") is False, \"Fee paid status mismatch\"\n\n    finally:\n        # Cleanup fee\n        if 'fee_id' in locals() and fee_id:\n            requests.delete(f\"{BASE_URL}/api/hostel/fees/{fee_id}\", headers=headers, timeout=TIMEOUT)\n        # Cleanup allocation\n        if allocation_id:\n            requests.delete(f\"{BASE_URL}/api/hostel/allocations/{allocation_id}\", headers=headers, timeout=TIMEOUT)\n        # Cleanup room\n        if room_id:\n            requests.delete(f\"{BASE_URL}/api/hostel/rooms/{room_id}\", headers=headers, timeout=TIMEOUT)\n        # Cleanup student\n        if student_id:\n            requests.delete(f\"{BASE_URL}/api/student/{student_id}\", headers=headers, timeout=TIMEOUT)\n\ntest_hostel_room_allocation_and_fee_management()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 94, in <module>\n  File \"<string>\", line 32, in test_hostel_room_allocation_and_fee_management\nAssertionError: Expected 201 Created, got 400\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-29T19:30:05.202Z",
    "modified": "2025-09-29T19:32:00.567Z"
  },
  {
    "projectId": "cfa9b81f-b57b-4c59-a209-6a1a1983491f",
    "testId": "d09ea6c1-e9e9-4ed0-8a72-ced2a02a2b3d",
    "userId": "e4384488-b011-7080-1f43-4f7481be94d5",
    "title": "TC005-exam scheduling result entry and result publication",
    "description": "Test the exam management APIs for scheduling exams, entering results, and publishing results for student access without errors.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:5000\"\nTIMEOUT = 30\nHEADERS = {\"Content-Type\": \"application/json\"}\n\ndef test_exam_scheduling_result_entry_and_publication():\n    exam_schedule_id = None\n    try:\n        # Step 1: Schedule an exam\n        schedule_payload = {\n            \"examName\": \"Midterm Exam\",\n            \"courseId\": 101,\n            \"examDate\": \"2025-10-15T09:00:00Z\",\n            \"duration\": 120,\n            \"location\": \"Room 100\"\n        }\n        schedule_resp = requests.post(\n            f\"{BASE_URL}/api/exams/schedule\",\n            json=schedule_payload,\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        assert schedule_resp.status_code == 201, f\"Schedule exam failed: {schedule_resp.text}\"\n        exam_schedule = schedule_resp.json()\n        exam_schedule_id = exam_schedule.get(\"id\")\n        assert exam_schedule_id is not None, \"Exam schedule ID not returned\"\n\n        # Step 2: Enter exam results for students\n        results_payload = {\n            \"examScheduleId\": exam_schedule_id,\n            \"results\": [\n                {\"studentId\": 201, \"marksObtained\": 85, \"grade\": \"A\"},\n                {\"studentId\": 202, \"marksObtained\": 78, \"grade\": \"B\"},\n                {\"studentId\": 203, \"marksObtained\": 92, \"grade\": \"A+\"}\n            ]\n        }\n        results_resp = requests.post(\n            f\"{BASE_URL}/api/exams/results\",\n            json=results_payload,\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        assert results_resp.status_code == 200, f\"Enter exam results failed: {results_resp.text}\"\n        results_data = results_resp.json()\n        assert results_data.get(\"success\") is True, \"Result entry unsuccessful\"\n\n        # Step 3: Publish results for student access\n        publish_resp = requests.post(\n            f\"{BASE_URL}/api/exams/publish\",\n            json={\"examScheduleId\": exam_schedule_id},\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        assert publish_resp.status_code == 200, f\"Publish results failed: {publish_resp.text}\"\n        publish_data = publish_resp.json()\n        assert publish_data.get(\"published\") is True, \"Result publication failed\"\n\n        # Step 4: Verify published results retrieval (simulate student access)\n        get_results_resp = requests.get(\n            f\"{BASE_URL}/api/exams/results/{exam_schedule_id}\",\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        assert get_results_resp.status_code == 200, f\"Get published results failed: {get_results_resp.text}\"\n        published_results = get_results_resp.json()\n        assert isinstance(published_results, list), \"Published results are not a list\"\n        assert len(published_results) == 3, \"Published results count mismatch\"\n        for result in published_results:\n            assert \"studentId\" in result\n            assert \"marksObtained\" in result\n            assert \"grade\" in result\n\n    finally:\n        # Cleanup: Delete the exam schedule and associated results if created\n        if exam_schedule_id:\n            requests.delete(\n                f\"{BASE_URL}/api/exams/schedule/{exam_schedule_id}\",\n                headers=HEADERS,\n                timeout=TIMEOUT,\n            )\n\ntest_exam_scheduling_result_entry_and_publication()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 83, in <module>\n  File \"<string>\", line 24, in test_exam_scheduling_result_entry_and_publication\nAssertionError: Schedule exam failed: \n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-29T19:30:05.211Z",
    "modified": "2025-09-29T19:31:40.013Z"
  },
  {
    "projectId": "cfa9b81f-b57b-4c59-a209-6a1a1983491f",
    "testId": "304713db-13ea-4b28-b0f9-91c998e0e687",
    "userId": "e4384488-b011-7080-1f43-4f7481be94d5",
    "title": "TC006-fee payment processing receipt generation and reporting",
    "description": "Verify the fee payment APIs to ensure payments are processed successfully, receipts are generated, and fee reports are accurate.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:5000\"\nTIMEOUT = 30\nHEADERS = {\"Content-Type\": \"application/json\"}\n\ndef test_fee_payment_processing_receipt_generation_and_reporting():\n    payment_id = None\n    try:\n        # Step 1: Process a fee payment\n        payment_payload = {\n            \"studentId\": str(uuid.uuid4()),  # Assuming studentId is a UUID string; create dummy studentId\n            \"amount\": 1500.00,\n            \"paymentMode\": \"CreditCard\",\n            \"paymentDate\": \"2025-09-29T10:00:00Z\",\n            \"feeType\": \"Tuition\",\n            \"notes\": \"Test payment for fee processing\"\n        }\n        payment_resp = requests.post(\n            f\"{BASE_URL}/api/fees/payments\",\n            json=payment_payload,\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert payment_resp.status_code == 201, f\"Fee payment creation failed: {payment_resp.text}\"\n        payment_data = payment_resp.json()\n        payment_id = payment_data.get(\"paymentId\")\n        assert payment_id, \"Payment ID not returned in response.\"\n\n        # Step 2: Retrieve receipt for the payment\n        receipt_resp = requests.get(\n            f\"{BASE_URL}/api/fees/payments/{payment_id}/receipt\",\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert receipt_resp.status_code == 200, f\"Receipt retrieval failed: {receipt_resp.text}\"\n        receipt_data = receipt_resp.json()\n        assert receipt_data.get(\"paymentId\") == payment_id, \"Receipt paymentId mismatch.\"\n        assert receipt_data.get(\"amount\") == payment_payload[\"amount\"], \"Receipt amount mismatch.\"\n        assert \"receiptNumber\" in receipt_data and receipt_data[\"receiptNumber\"], \"Receipt number missing.\"\n\n        # Step 3: Get fee report summary\n        report_params = {\n            \"studentId\": payment_payload[\"studentId\"],\n            \"fromDate\": \"2025-01-01\",\n            \"toDate\": \"2025-12-31\"\n        }\n        report_resp = requests.get(\n            f\"{BASE_URL}/api/fees/reports/summary\",\n            params=report_params,\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert report_resp.status_code == 200, f\"Fee report retrieval failed: {report_resp.text}\"\n        report_data = report_resp.json()\n        assert \"totalPaid\" in report_data and report_data[\"totalPaid\"] >= payment_payload[\"amount\"], \\\n            \"Fee report totalPaid is less than the payment made.\"\n        assert any(p[\"paymentId\"] == payment_id for p in report_data.get(\"payments\", [])), \\\n            \"Payment not found in fee report.\"\n\n    finally:\n        # Cleanup: delete the created payment resource if possible\n        if payment_id:\n            try:\n                del_resp = requests.delete(\n                    f\"{BASE_URL}/api/fees/payments/{payment_id}\",\n                    headers=HEADERS,\n                    timeout=TIMEOUT\n                )\n                # Accept 200 or 204 as successful deletion\n                assert del_resp.status_code in (200, 204), f\"Failed to delete payment resource: {del_resp.text}\"\n            except Exception:\n                pass\n\ntest_fee_payment_processing_receipt_generation_and_reporting()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 76, in <module>\n  File \"<string>\", line 26, in test_fee_payment_processing_receipt_generation_and_reporting\nAssertionError: Fee payment creation failed: \n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-29T19:30:05.226Z",
    "modified": "2025-09-29T19:30:54.598Z"
  },
  {
    "projectId": "cfa9b81f-b57b-4c59-a209-6a1a1983491f",
    "testId": "027d3a0e-4a79-44d6-a8ca-3ff1d43831c9",
    "userId": "e4384488-b011-7080-1f43-4f7481be94d5",
    "title": "TC007-role based access control enforcement",
    "description": "Test the role and user management APIs to confirm that role-based access controls prevent unauthorized access to system functionalities.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:5000\"\nTIMEOUT = 30\n\n# Assumed admin credentials with full access\nADMIN_AUTH = {\"Authorization\": \"Bearer admin-token-placeholder\"}\n\n# Assumed unauthorized user credentials (e.g., student role) token placeholder\nUNAUTHORIZED_AUTH = {\"Authorization\": \"Bearer student-token-placeholder\"}\n\n\ndef test_role_based_access_control_enforcement():\n    # Step 1: Create a role with limited permissions (e.g., read-only)\n    role_data = {\n        \"name\": \"limited_role\",\n        \"permissions\": [\"read_only\"]\n    }\n    created_role_id = None\n    created_user_id = None\n    try:\n        # Create Role as admin\n        response = requests.post(\n            f\"{BASE_URL}/api/roles\",\n            json=role_data,\n            headers=ADMIN_AUTH,\n            timeout=TIMEOUT,\n        )\n        assert response.status_code == 201, f\"Role creation failed: {response.text}\"\n        created_role = response.json()\n        created_role_id = created_role.get(\"id\")\n        assert created_role_id is not None, \"Created role ID is None\"\n\n        # Step 2: Create a user with this limited role\n        user_data = {\n            \"username\": \"test_limited_user\",\n            \"password\": \"TestPass123!\",\n            \"email\": \"test_limited_user@example.com\",\n            \"roleId\": created_role_id,\n            \"fullName\": \"Test Limited User\"\n        }\n        response = requests.post(\n            f\"{BASE_URL}/api/users\",\n            json=user_data,\n            headers=ADMIN_AUTH,\n            timeout=TIMEOUT,\n        )\n        assert response.status_code == 201, f\"User creation failed: {response.text}\"\n        created_user = response.json()\n        created_user_id = created_user.get(\"id\")\n        assert created_user_id is not None, \"Created user ID is None\"\n\n        # Step 3: Authenticate as the limited user to obtain a token\n        auth_data = {\"username\": user_data[\"username\"], \"password\": user_data[\"password\"]}\n        response = requests.post(f\"{BASE_URL}/api/auth/login\", json=auth_data, timeout=TIMEOUT)\n        assert response.status_code == 200, f\"Authentication failed: {response.text}\"\n        token = response.json().get(\"token\")\n        assert token, \"Token not received on login\"\n        limited_user_auth = {\"Authorization\": f\"Bearer {token}\"}\n\n        # Step 4: Try to access an admin-only endpoint - e.g. creating another role (which limited user should not be allowed)\n        forbidden_role_data = {\"name\": \"forbidden_role\", \"permissions\": [\"admin\"]}\n        resp = requests.post(\n            f\"{BASE_URL}/api/roles\",\n            json=forbidden_role_data,\n            headers=limited_user_auth,\n            timeout=TIMEOUT,\n        )\n        assert resp.status_code in (401, 403), (\n            f\"Unauthorized user was able to create role or unexpected status {resp.status_code}: {resp.text}\"\n        )\n\n        # Step 5: Try to access allowed resource (e.g., role info read)\n        # Limited role has read_only, so GET roles should be allowed or unauthorized depending on system implementation\n        resp = requests.get(\n            f\"{BASE_URL}/api/roles\",\n            headers=limited_user_auth,\n            timeout=TIMEOUT,\n        )\n        # Accept 200 or 403/401 depending on implementation; just check no 500 error\n        assert resp.status_code in (200, 401, 403), f\"Unexpected status code on role list: {resp.status_code}\"\n\n        # Step 6: Test unauthorized access with invalid token (simulate no access)\n        resp = requests.get(f\"{BASE_URL}/api/roles\", headers={\"Authorization\": \"Bearer invalidtoken\"}, timeout=TIMEOUT)\n        assert resp.status_code in (401, 403), \"Invalid token should not allow access\"\n\n    finally:\n        # Cleanup: delete created user and role\n        headers = ADMIN_AUTH\n        if created_user_id:\n            try:\n                requests.delete(f\"{BASE_URL}/api/users/{created_user_id}\", headers=headers, timeout=TIMEOUT)\n            except Exception:\n                pass\n        if created_role_id:\n            try:\n                requests.delete(f\"{BASE_URL}/api/roles/{created_role_id}\", headers=headers, timeout=TIMEOUT)\n            except Exception:\n                pass\n\n\ntest_role_based_access_control_enforcement()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 102, in <module>\n  File \"<string>\", line 29, in test_role_based_access_control_enforcement\nAssertionError: Role creation failed: \n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-29T19:30:05.242Z",
    "modified": "2025-09-29T19:31:55.487Z"
  },
  {
    "projectId": "cfa9b81f-b57b-4c59-a209-6a1a1983491f",
    "testId": "7ffc6a50-76b4-42a8-9ce2-d5fe79e8f2bc",
    "userId": "e4384488-b011-7080-1f43-4f7481be94d5",
    "title": "TC008-real time dashboard updates using signalr",
    "description": "Validate the real-time dashboard API using SignalR to ensure timely and accurate updates and notifications are delivered to users.",
    "code": "import threading\nimport time\nimport requests\nfrom requests.exceptions import RequestException\nfrom urllib.parse import urljoin\nfrom signalrcore.hub_connection_builder import HubConnectionBuilder\n\nBASE_URL = \"http://localhost:5000\"\nSIGNALR_HUB_URL = urljoin(BASE_URL, \"/dashboardhub\")\nTIMEOUT = 30\n\ndef test_real_time_dashboard_updates_using_signalr():\n    received_messages = []\n    error_during_connection = []\n\n    # Function to run the SignalR connection and listen for messages\n    def run_signalr_client():\n        try:\n            hub_connection = HubConnectionBuilder()\\\n                .with_url(SIGNALR_HUB_URL)\\\n                .configure_logging(print)\\\n                .build()\n\n            def on_open():\n                # SignalR connection opened\n                pass\n\n            def on_close():\n                # SignalR connection closed\n                pass\n\n            def on_error(error):\n                error_during_connection.append(error)\n\n            def on_update(args):\n                # Received update message from hub\n                received_messages.append(args)\n\n            hub_connection.on_open(on_open)\n            hub_connection.on_close(on_close)\n            hub_connection.on_error(on_error)\n            hub_connection.on(\"ReceiveDashboardUpdate\", on_update)\n\n            hub_connection.start()\n            # Keep connection alive for 15 seconds to receive messages\n            time.sleep(15)\n            hub_connection.stop()\n        except Exception as e:\n            error_during_connection.append(e)\n\n    thread = threading.Thread(target=run_signalr_client)\n    thread.start()\n    thread.join(timeout=TIMEOUT)\n\n    assert not error_during_connection, f\"Errors during SignalR connection: {error_during_connection}\"\n    assert len(received_messages) > 0, \"No real-time dashboard updates received from SignalR hub.\"\n\n    for message in received_messages:\n        assert isinstance(message, list) or isinstance(message, dict), \"Received message format is invalid.\"\n        # Example minimal validation of message content\n        if isinstance(message, list) and len(message) > 0:\n            first_item = message[0]\n            assert isinstance(first_item, dict), \"Dashboard update items should be dicts.\"\n            # Validate expected fields if any, e.g. timestamp and data keys\n            assert \"timestamp\" in first_item or \"updateType\" in first_item, \"Expected keys missing in update.\"\n        elif isinstance(message, dict):\n            assert \"timestamp\" in message or \"updateType\" in message, \"Expected keys missing in update.\"\n\ntest_real_time_dashboard_updates_using_signalr()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 6, in <module>\nModuleNotFoundError: No module named 'signalrcore'\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-09-29T19:30:05.252Z",
    "modified": "2025-09-29T19:30:54.161Z"
  }
]
